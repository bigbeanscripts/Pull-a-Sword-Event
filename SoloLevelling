local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()

local Window = Library:Window{
    Title = "Pull a Sword Event",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size =  UDim2.fromOffset(580, 460),
    Resize = false, 
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}

local Tabs = {
    Event = Window:AddTab({ Title = "Event", Icon = "sword" })
}




-- Add Event Section
local EventSection = Tabs.Event:AddSection("Main Farm")

-- Toggle Setup
local Toggle = EventSection:AddToggle("AutoTrainToggle", {
    Title = "Auto Train",
    Description = "Automatically trains and equips the best clickers.",
    Default = false
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local EggsFolder = ReplicatedStorage:WaitForChild("Items"):WaitForChild("Eggs")
local ClickChangeEvent = ReplicatedStorage.Remotes.Events:WaitForChild("ClickChangeEvent")
local ClickEvent = ReplicatedStorage.Remotes.Events:WaitForChild("ClickEvent")

local running = false

-- Equip Best Function
local function equipBestEgg()
    local player = Players.LocalPlayer
    local strength = player:FindFirstChild("PowerEggs") -- Player's actual strength

    if not (strength and strength:IsA("NumberValue")) then
        warn("Missing PowerEggs (strength)")
        return
    end

    local bestEgg = nil
    local highestRequirement = -math.huge

    for i = 1, 12 do
        local egg = EggsFolder:FindFirstChild(tostring(i))
        if egg then
            local config = egg:FindFirstChild("Configuration")
            if config then
                local powerReq = config:FindFirstChild("PowerReq")

                if powerReq and powerReq:IsA("NumberValue") then
                    if strength.Value >= powerReq.Value and powerReq.Value > highestRequirement then
                        highestRequirement = powerReq.Value
                        bestEgg = egg
                    end
                end
            end
        end
    end

    if bestEgg then
        ClickChangeEvent:FireServer(bestEgg, true)
    end
end

-- Toggle Listener
Toggle:OnChanged(function(enabled)
    running = enabled

    if enabled then
        -- Equip best immediately
        equipBestEgg()

        -- Constantly re-equip best every 5 seconds
        task.spawn(function()
            while running do
                task.wait(5)
                equipBestEgg()
            end
        end)

        -- Constant ClickEvent firing
        task.spawn(function()
            while running do
                task.wait(0.01)
                ClickEvent:FireServer()
            end
        end)
    end
end)



local RunService = game:GetService("RunService")

-- Auto Dungeon Section
local AutoDungeonSection = Tabs.Event:AddSection("Auto Dungeon")

-- Dropdown for selecting dungeon difficulty
local DifficultyDropdown = AutoDungeonSection:AddDropdown("DungeonDifficulty", {
    Title = "Dungeon Difficulty",
    Description = "Select the difficulty for auto dungeon",
    Values = {"Normal", "Hard", "Chaos"},
    Default = "Normal",
})

-- Toggle to enable/disable auto dungeon
local AutoDungeonToggle = AutoDungeonSection:AddToggle("AutoDungeon", {
    Title = "Auto Dungeon/Fight",
    Description = "Automatically joins, fights, and teleports to dungeon NPCs",
    Default = false,
})

AutoDungeonToggle:OnChanged(function()
    if AutoDungeonToggle.Value then
        -- Auto Fight
        spawn(function()
            while AutoDungeonToggle.Value do
                game:GetService("ReplicatedStorage").Remotes.Events.Dungeon.OnDungeonClick:FireServer()
                wait(0.1)
            end
        end)

        -- Auto Join
        spawn(function()
            while AutoDungeonToggle.Value do
                local difficulty = DifficultyDropdown.Value
                game:GetService("ReplicatedStorage").Remotes.Events.Dungeon.OnJoinDungeon:FireServer(difficulty)
                wait(2)
            end
        end)

-- NPC teleport + lock state
local currentNPC = nil
local lastNPCChange = tick()
local initialTeleport = true -- Flag to track initial teleport

local function checkForNPC()
    if not AutoDungeonToggle.Value then return end

    local difficulty = DifficultyDropdown.Value
    local targetNPC = workspace.LiveObjects.NPCs:FindFirstChild(difficulty)
    if not targetNPC then
        targetNPC = workspace.LiveObjects.NPCs:FindFirstChildOfClass("Model")
    end

    if targetNPC and targetNPC:FindFirstChild("HumanoidRootPart") then
        if targetNPC ~= currentNPC then
            currentNPC = targetNPC
            lastNPCChange = tick()
            initialTeleport = true -- Reset flag for new NPC

            task.wait(1)
            local character = game.Players.LocalPlayer.Character
            if character then
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    -- Teleport 12 units above the NPC initially
                    hrp.CFrame = currentNPC.HumanoidRootPart.CFrame + Vector3.new(0, 15, -0.45)
                end
            end
        end
    end
end

-- Initial check
checkForNPC()

-- React to new NPCs
local npcAddedConnection = workspace.LiveObjects.NPCs.ChildAdded:Connect(function()
    checkForNPC()
end)
AutoDungeonToggle._connection = npcAddedConnection

-- Lock Y position and handle drop down from 12 to 8
local dropDelay = 1.5 -- Wait 1 second before dropping down
AutoDungeonToggle._steppedConnection = RunService.Stepped:Connect(function()
    if AutoDungeonToggle.Value and currentNPC and currentNPC:FindFirstChild("HumanoidRootPart") then
        local character = game.Players.LocalPlayer.Character
        if character then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                -- If initial teleport and it's been more than dropDelay seconds since NPC change
                if initialTeleport and (tick() - lastNPCChange > dropDelay) then
                    initialTeleport = false -- No longer in initial position
                end

                -- Position is 12 units up if in initial state, otherwise 8 units up
                local heightOffset = initialTeleport and 15 or 10
                local targetPos = currentNPC.HumanoidRootPart.Position + Vector3.new(0, heightOffset, -0.45)
                
                hrp.Velocity = Vector3.zero -- freeze gravity drop
                hrp.CFrame = CFrame.new(targetPos)
            end
        end
    end
end)

    else
        -- Cleanup
        if AutoDungeonToggle._connection then
            AutoDungeonToggle._connection:Disconnect()
            AutoDungeonToggle._connection = nil
        end

        if AutoDungeonToggle._steppedConnection then
            AutoDungeonToggle._steppedConnection:Disconnect()
            AutoDungeonToggle._steppedConnection = nil
        end
    end
end)


-- Create the Player Upgrades section
local PlayerUpgradesSection = Tabs.Event:AddSection("Player Upgrades")

-- Add Status Label for Player Stats
local PlayerStatsStatus = PlayerUpgradesSection:Paragraph("PlayerInfo", {
    Title = "Player Stats & Prices",
    Content = "Loading..."
})

-- Price table for upgrades
local function getPriceForLevel(level)
    local prices = {
        [1] = 100,
        [2] = 500,
        [3] = 2500,
        [4] = 10000,
        [5] = 50000,
        [6] = 500000,
        [7] = 5000000,
        [8] = 50000000
    }
    
    return prices[level] or 999999999 -- Return a very high price for unknown levels
end

-- Function to parse amount text and handle 'k' suffix
local function parseAmount(amtText)
    local numStr = amtText:match("%d+%.?%d*")
    if not numStr then return 0 end
    
    if amtText:find("K") or amtText:find("k") then
        local baseNum = tonumber(numStr)
        return baseNum and (baseNum * 1000) or 0
    else
        return tonumber(numStr) or 0
    end
end

-- Function to format large numbers
local function formatNumber(num)
    if num >= 1000000 then
        return string.format("%.1fM", num / 1000000)
    elseif num >= 1000 then
        return string.format("%.1fK", num / 1000)
    else
        return tostring(num)
    end
end

-- Update Player Stats status (always runs to update the counter)
spawn(function()
    while true do
        local player = game:GetService("Players").LocalPlayer
        local runesAmount = 0
        local powerLevel = 1
        local healthLevel = 1
        
        -- Get current values
        pcall(function()
            runesAmount = player.PlayerMoreInventory.VictoryTokens.Value
            powerLevel = player.Cache.UpgradedStats.Stats.PowerMultiply.Value
            healthLevel = player.Cache.UpgradedStats.Stats.Health.Value
        end)
        
        local powerPrice = getPriceForLevel(powerLevel)
        local healthPrice = getPriceForLevel(healthLevel)
        
        local statusText = "Victory Tokens: " .. formatNumber(runesAmount) .. "\n\n"
        statusText = statusText .. "Power Level: " .. powerLevel .. "\n"
        statusText = statusText .. "Next Upgrade: " .. formatNumber(powerPrice) .. " Victory Tokens \n\n"
        statusText = statusText .. "Health Level: " .. healthLevel .. "\n"
        statusText = statusText .. "Next Upgrade: " .. formatNumber(healthPrice) .. " Victory Tokens"
        
        PlayerStatsStatus:SetContent(statusText)
        
        task.wait(1) -- Update status every second
    end
end)

-- Add Power Multiply toggle
local PowerMultiplyToggle = PlayerUpgradesSection:AddToggle("PowerMultiplyToggle", {
    Title = "Auto Power Multiply Upgrade",
    Description = "Automatically purchase Power Multiplier upgrades when affordable.",
    Default = false
})

local powerMultiplyLoop = nil

PowerMultiplyToggle:OnChanged(function(enabled)
    if enabled then
        powerMultiplyLoop = spawn(function()
            while PowerMultiplyToggle.Value do
                -- Check if player can afford upgrade
                local player = game:GetService("Players").LocalPlayer
                local runesAmount = 0
                local powerLevel = 1
                
                pcall(function()
                    runesAmount = player.PlayerMoreInventory.VictoryTokens.Value
                    powerLevel = player.Cache.UpgradedStats.Stats.PowerMultiply.Value
                end)
                
                local price = getPriceForLevel(powerLevel)
                local canAfford = runesAmount >= price
                
                if canAfford then
                    local args = {
                        [1] = "PowerMultiply"
                    }

                    game:GetService("ReplicatedStorage").Remotes.Events.OnUpgradedRequests:FireServer(unpack(args))
                    -- Short wait before checking again
                    task.wait(1)
                else
                    -- Wait before checking again if can't afford
                    task.wait(5)
                end
            end
        end)
    else
        -- Cancel the loop if it exists
        if powerMultiplyLoop then
            powerMultiplyLoop:Cancel()
            powerMultiplyLoop = nil
        end
    end
end)

-- Add Health toggle
local HealthToggle = PlayerUpgradesSection:AddToggle("HealthToggle", {
    Title = "Auto Health Upgrade",
    Description = "Automatically purchase Health upgrades when affordable.",
    Default = false
})

local healthLoop = nil

HealthToggle:OnChanged(function(enabled)
    if enabled then
        healthLoop = spawn(function()
            while HealthToggle.Value do
                -- Check if player can afford upgrade
                local player = game:GetService("Players").LocalPlayer
                local runesAmount = 0
                local healthLevel = 1
                
                pcall(function()
                    runesAmount = player.PlayerMoreInventory.VictoryTokens.Value
                    healthLevel = player.Cache.UpgradedStats.Health.Value
                end)
                
                local price = getPriceForLevel(healthLevel)
                local canAfford = runesAmount >= price
                
                if canAfford then
                    -- Run the upgrade request
                    local args = {
                        [1] = "Health"
                    }
                    game:GetService("ReplicatedStorage").Remotes.Events.OnUpgradedRequests:FireServer(unpack(args))
                    
                    -- Short wait before checking again
                    task.wait(1)
                else
                    -- Wait before checking again if can't afford
                    task.wait(5)
                end
            end
        end)
    else
        -- Cancel the loop if it exists
        if healthLoop then
            healthLoop:Cancel()
            healthLoop = nil
        end
    end
end)
